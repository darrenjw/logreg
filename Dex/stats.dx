'# Stats
Probability distributions and other functions useful for statistical computing


'## Univariate probability distributions
Simulation and evaluation of random variables. Random variables are listed in alphabetical order except for the exponential distribution, which is listed first as an exemplar simple yet complete implementation.

'## Dist interface
Distributions implement the `Dist` interface.

interface Dist d a
  logpdf : d -> a -> Float
  logcdf : d -> a -> Float
  logsurv : d -> a -> Float
  quantile : d -> Float -> a
  draw : d -> Key -> a


'### Exponential
Parameterised by the *rate*, `r > 0`, so that the mean of the distribution is `1/r`.

data ExponentialDist = Exponential Float

instance Dist ExponentialDist Float
  logpdf = \(Exponential r) x.
    if (x < 0.0)
      then -infinity
      else (log r) - (r * x)
  logcdf = \(Exponential r) x.
    if (x < 0.0)
      then -infinity
      else log1p (-exp (-r * x))
  logsurv = \(Exponential r) x.
    if (x < 0.0)
      then 0.0
      else -r * x
  quantile = \(Exponential r) q.
    (log1p (-q)) / -r
  draw = \(Exponential r) k.
    (log1p (-(rand k))) / -r


'### Bernoulli distribution
Parameterised by its "success" probability, `p`.

data BernoulliDist = Bernoulli Float

instance Dist BernoulliDist Bool
  logpdf = \(Bernoulli p) b.
    if (b)
     then log p
     else log1p (-p)
  logcdf = todo
  logsurv = todo
  quantile = todo
  draw = \(Bernoulli p) k.
    bern p k -- TODO: move "bern" here from the prelude


'### Binomial distribution
Parameterised by the number of trials, `n`, and the success probability, `p`. Mean is `np`.

data BinomialDist = Binomial Nat Float

instance Dist BinomialDist Nat
  logpdf = \(Binomial n p) x.
    nf = n_to_f n
    xf = n_to_f x
    (xf * (log p)) + ((nf - xf) * (log1p (-p))) +
      (lgamma (nf + 1)) - (lgamma (xf + 1)) - (lgamma (nf + 1 - xf))
  logcdf = todo
  logsurv = todo
  quantile = todo
  draw = \(Binomial n p) k.
    binom n p k -- TODO: move "binom" here from the prelude


'### Gaussian distribution
Parameterised by its *mean*, `mu`, and *standard deviation*, `sig`. ie. **not** variance or precision.

data GaussianDist = Gaussian Float Float

instance Dist GaussianDist Float
  logpdf = \(Gaussian mu sig) x.
    -0.5 * ((log (2 * pi * (sq sig))) + (sq ((x - mu) / sig)))
  logcdf = todo -- need some sort of "erf" function for this
  logsurv = todo --- ditto
  quantile = todo
  draw = \(Gaussian mu sig) k.
    mu + (sig * (randn k))


'### Geometric distribution
Number of trials until a success (**not** number of failures). Parameterised by success probability, `p`. Mean is `1/p`.

data GeometricDist = Geometric Float

instance Dist GeometricDist Nat
  logpdf = \(Geometric p) n.
    nf = n_to_f n
    ((nf-1)*(log1p (-p))) + (log p)
  logcdf = \(Geometric p) n.
    nf = n_to_f n
    log1p (-pow (1-p) nf)
  logsurv = \(Geometric p) n.
    (n_to_f n) * (log1p (-p))
  quantile = todo
  draw = \(Geometric p) k.
    yield_state 1 \x.
      with_state k \ks.
        while do
          [k1, k2] = split_key (get ks)
          if (bern p k1)
            then
              False
            else
              x := (get x) + 1
              ks := k2
              True


'### Poisson distribution
Parameterised by its rate, `r > 0`. Mean is `r`.

data PoissonDist = Poisson Float

instance Dist PoissonDist Nat
  logpdf = \(Poisson r) n.
    nf = n_to_f n
    (nf * (log r)) - r - lgamma(nf + 1)
  logcdf = todo
  logsurv = todo
  quantile = todo
  draw = \(Poisson r) k.
    poisson r k -- TODO: move "poisson" from prelude to here
  

'### Uniform distribution
A continuous distribution uniform on an interval determined by a lower bound, `l`, and upper bound, `u > l`. Mean is `(l+u)/2`.

data UniformDist = Uniform Float Float

instance Dist UniformDist Float
  logpdf = \(Uniform l u) x.
    if (x >= l)&&(x <= u)
      then -log (u - l)
      else -infinity
  logcdf = \(Uniform l u) x.
    if (x < l)
      then -infinity
      else if (x > u)
        then 0.0
        else (log (x-l)) - (log (u-l))
  logsurv = \(Uniform l u) x.
    if (x < l)
      then 0.0
      else if (x > u)
        then -infinity
        else (log (u-x)) - (log (u-l))
  quantile = \(Uniform l u) q.
    l + ((u - l) * q)
  draw = \(Uniform l u) k.
    l + ((u - l) * (rand k))
  
  
  

'## Data summaries


def meanAndVar {n} (v:n=>Float) : (Float & Float) =
  m = mean v
  ss = sum for i. sq (v.i - m)
  v = ss / ((n_to_f (size n)) - 1.0)
  (m, v)




-- eof

