'# Stats
Probability distributions and other functions useful for statistical computing


'## Univariate probability distributions
Simulation and evaluation of random variables. Random variables are listed in alphabetical order except for the exponential distribution, which is listed first as an exemplar simple yet complete implementation.

'## Dist interface
Distributions implement the `Dist` interface.

interface Dist d a
  log_pdf : d -> a -> Float     -- either the density function or mass function
  log_cdf : d -> a -> Float     -- the cumulative distribution function (CDF)
  log_sf : d -> a -> Float      -- the survivor function (complement of CDF)
  quantile : d -> Float -> a    -- the quantile function (inverse CDF)
  draw : d -> Key -> a          -- function for random draws


'### Exponential
Parameterised by the *rate*, `r > 0`, so that the mean of the distribution is `1/r`.

data ExponentialDist = Exponential Float

instance Dist ExponentialDist Float
  log_pdf = \(Exponential r) x.
    if (x < 0.0)
      then -infinity
      else (log r) - (r * x)
  log_cdf = \(Exponential r) x.
    if (x < 0.0)
      then -infinity
      else log1p (-exp (-r * x))
  log_sf = \(Exponential r) x.
    if (x < 0.0)
      then 0.0
      else -r * x
  quantile = \(Exponential r) q.
    (log1p (-q)) / -r
  draw = \(Exponential r) k.
    (log1p (-(rand k))) / -r


'### Bernoulli distribution
Parameterised by its "success" probability, `p`.

data BernoulliDist = Bernoulli Float

instance Dist BernoulliDist Bool
  log_pdf = \(Bernoulli p) b.
    if (b)
     then log p
     else log1p (-p)
  log_cdf = todo
  log_sf = todo
  quantile = todo
  draw = \(Bernoulli p) k.
    bern p k -- TODO: move "bern" here from the prelude


'### Binomial distribution
Parameterised by the number of trials, `n`, and the success probability, `p`. Mean is `np`.

data BinomialDist = Binomial Nat Float

instance Dist BinomialDist Nat
  log_pdf = \(Binomial n p) x.
    nf = n_to_f n
    xf = n_to_f x
    (xf * (log p)) + ((nf - xf) * (log1p (-p))) +
      (lgamma (nf + 1)) - (lgamma (xf + 1)) - (lgamma (nf + 1 - xf))
  log_cdf = todo
  log_sf = todo
  quantile = todo
  draw = \(Binomial n p) k.
    binom n p k -- TODO: move "binom" here from the prelude


'### Gaussian distribution
Parameterised by its *mean*, `mu`, and *standard deviation*, `sig`. ie. **not** variance or precision.

data GaussianDist = Gaussian Float Float

instance Dist GaussianDist Float
  log_pdf = \(Gaussian mu sig) x.
    -0.5 * ((log (2 * pi * (sq sig))) + (sq ((x - mu) / sig)))
  log_cdf = todo -- need some sort of "erf" function for this
  log_sf = todo --- ditto
  quantile = todo
  draw = \(Gaussian mu sig) k.
    mu + (sig * (randn k))


'### Geometric distribution
Number of trials until a success (**not** number of failures). Parameterised by success probability, `p`. Mean is `1/p`.

data GeometricDist = Geometric Float

instance Dist GeometricDist Nat
  log_pdf = \(Geometric p) n.
    nf = n_to_f n
    ((nf-1)*(log1p (-p))) + (log p)
  log_cdf = \(Geometric p) n.
    nf = n_to_f n
    log1p (-pow (1-p) nf)
  log_sf = \(Geometric p) n.
    (n_to_f n) * (log1p (-p))
  quantile = todo
  draw = \(Geometric p) k.
    yield_state 1 \x.
      with_state k \ks.
        while do
          [k1, k2] = split_key (get ks)
          if (bern p k1)
            then
              False
            else
              x := (get x) + 1
              ks := k2
              True


'### Poisson distribution
Parameterised by its rate, `r > 0`. Mean is `r`.

data PoissonDist = Poisson Float

instance Dist PoissonDist Nat
  log_pdf = \(Poisson r) n.
    nf = n_to_f n
    (nf * (log r)) - r - lgamma(nf + 1)
  log_cdf = todo
  log_sf = todo
  quantile = todo
  draw = \(Poisson r) k.
    poisson r k -- TODO: move "poisson" from prelude to here
  

'### Uniform distribution
A continuous distribution uniform on an interval determined by a lower bound, `l`, and upper bound, `u > l`. Mean is `(l+u)/2`.

data UniformDist = Uniform Float Float

instance Dist UniformDist Float
  log_pdf = \(Uniform l u) x.
    if (x >= l)&&(x <= u)
      then -log (u - l)
      else -infinity
  log_cdf = \(Uniform l u) x.
    if (x < l)
      then -infinity
      else if (x > u)
        then 0.0
        else (log (x-l)) - (log (u-l))
  log_sf = \(Uniform l u) x.
    if (x < l)
      then 0.0
      else if (x > u)
        then -infinity
        else (log (u-x)) - (log (u-l))
  quantile = \(Uniform l u) q.
    l + ((u - l) * q)
  draw = \(Uniform l u) k.
    l + ((u - l) * (rand k))
  
  
  

'## Data summaries


def mean_and_var {n} (xs:n=>Float) : (Float & Float) =
  m = mean xs
  ss = sum for i. sq (xs.i - m)
  v = ss / ((n_to_f (size n)) - 1.0)
  (m, v)

def var {n} (xs:n=>Float) : Float =
  snd $ mean_and_var xs

def sd {n} (xs:n=>Float) : Float =
  sqrt $ var xs

def mean_and_cov {n d} (xs:n=>d=>Float) : (d=>Float & d=>d=>Float) =
   xsMean :    d=>Float = (for i. sum for j. xs.j.i) / n_to_f (size n)
   xsCov  : d=>d=>Float = (for i i'. sum for j.
                           (xs.j.i' - xsMean.i') *
                           (xs.j.i  - xsMean.i )   ) / (n_to_f (size n) - 1)
   (xsMean, xsCov)

def cov {n d} (xs:n=>d=>Float) : d=>d=>Float =
  snd $ mean_and_cov xs



